!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("crypto")):"function"==typeof define&&define.amd?define(["exports","crypto"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).fief={},e.crypto$2)}(this,(function(e,t){"use strict";function r(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var n=r(t);function i(e,t,r,n){return new(r||(r=Promise))((function(i,o){function a(e){try{c(n.next(e))}catch(e){o(e)}}function s(e){try{c(n.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,s)}c((n=n.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;class o extends Error{}class a extends o{}const s=e=>btoa(String.fromCharCode(...new Uint8Array(e))).replace(/=/g,"").replace(/[+/]/g,(e=>"+"===e?"-":"_"));class c{constructor(){if("undefined"!=typeof window&&window.crypto&&(this.crypto=window.crypto),"undefined"!=typeof self&&self.crypto&&(this.crypto=self.crypto),"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime&&(this.crypto=globalThis.crypto),void 0===this.crypto)throw new a("Cannot find the Crypto module. Are you sure you are in a browser environment?")}getValidationHash(e){return i(this,void 0,void 0,(function*(){const t=(new TextEncoder).encode(e),r=yield this.crypto.subtle.digest("SHA-256",t),n=r.slice(0,r.byteLength/2);return s(n)}))}isValidHash(e,t){return i(this,void 0,void 0,(function*(){return(yield this.getValidationHash(e))===t}))}generateCodeVerifier(){return i(this,void 0,void 0,(function*(){const e=new Uint8Array(96);return this.crypto.getRandomValues(e),s(e)}))}getCodeChallenge(e,t){return i(this,void 0,void 0,(function*(){if("plain"===t)return e;if("S256"===t){const t=(new TextEncoder).encode(e),r=yield this.crypto.subtle.digest("SHA-256",t);return s(r)}throw new o(`Invalid method "${t}". Allowed methods are: plain, S256`)}))}}class d extends o{}class h{constructor(){if(this.crypto=n,void 0===this.crypto)throw new d("Cannot find the Crypto module. Are you sure you are in a browser environment?")}getValidationHash(e){return i(this,void 0,void 0,(function*(){const t=(new TextEncoder).encode(e),r=this.crypto.createHash("sha256").update(t).digest(),n=r.subarray(0,r.byteLength/2);return Buffer.from(new Uint8Array(n)).toString("base64url")}))}isValidHash(e,t){return i(this,void 0,void 0,(function*(){return(yield this.getValidationHash(e))===t}))}generateCodeVerifier(){return i(this,void 0,void 0,(function*(){return new Promise(((e,t)=>{this.crypto.randomBytes(96,((r,n)=>{r?t(r):e(n.toString("base64url"))}))}))}))}getCodeChallenge(e,t){return i(this,void 0,void 0,(function*(){if("plain"===t)return e;if("S256"===t){const t=(new TextEncoder).encode(e);return this.crypto.createHash("sha256").update(t).digest("base64url")}throw new o(`Invalid method "${t}". Allowed methods are: plain, S256`)}))}}const l=()=>{if("undefined"!=typeof window||"undefined"!=typeof self||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)return new c;if("function"==typeof require)return new h;throw new o("Cannot find a crypto implementation for your environment")};var u=Object.freeze({__proto__:null,getCrypto:l,CryptoHelperError:o});class f{constructor(){this.storage=window.sessionStorage}getUserinfo(){const e=this.storage.getItem(f.USERINFO_STORAGE_KEY);return e?JSON.parse(e):null}setUserinfo(e){this.storage.setItem(f.USERINFO_STORAGE_KEY,JSON.stringify(e))}clearUserinfo(){this.storage.removeItem(f.USERINFO_STORAGE_KEY)}getTokenInfo(){const e=this.storage.getItem(f.TOKEN_INFO_STORAGE_KEY);return e?JSON.parse(e):null}setTokenInfo(e){this.storage.setItem(f.TOKEN_INFO_STORAGE_KEY,JSON.stringify(e))}clearTokeninfo(){this.storage.removeItem(f.TOKEN_INFO_STORAGE_KEY)}getCodeVerifier(){const e=this.storage.getItem(f.CODE_VERIFIER_STORAGE_KEY);return e||null}setCodeVerifier(e){this.storage.setItem(f.CODE_VERIFIER_STORAGE_KEY,e)}clearCodeVerifier(){this.storage.removeItem(f.CODE_VERIFIER_STORAGE_KEY)}}f.USERINFO_STORAGE_KEY="fief-userinfo",f.TOKEN_INFO_STORAGE_KEY="fief-tokeninfo",f.CODE_VERIFIER_STORAGE_KEY="fief-codeverifier";class p extends Error{}class y extends p{constructor(e,t=null){super(),this.error=e,this.description=t}}class w extends p{}var g=Object.freeze({__proto__:null,FiefAuthError:p,FiefAuthAuthorizeError:y,FiefAuthNotAuthenticatedError:w,FiefAuth:class{constructor(e,t){this.client=e,this.storage=void 0!==t?t:new f,this.crypto=l(),this.pendingAuthCallbacks=new Set}isAuthenticated(){return null!==this.storage.getTokenInfo()}getUserinfo(){return this.storage.getUserinfo()}getTokenInfo(){return this.storage.getTokenInfo()}redirectToLogin(e,t){return i(this,void 0,void 0,(function*(){const r=yield this.crypto.generateCodeVerifier(),n=yield this.crypto.getCodeChallenge(r,"S256");this.storage.setCodeVerifier(r);const i=yield this.client.getAuthURL(Object.assign(Object.assign(Object.assign({redirectURI:e,scope:(null==t?void 0:t.scope)||["openid"],codeChallenge:n,codeChallengeMethod:"S256"},(null==t?void 0:t.state)?{state:t.state}:{}),(null==t?void 0:t.state)?{lang:t.lang}:{}),(null==t?void 0:t.extrasParams)?{extrasParams:t.extrasParams}:{}));window.location.href=i}))}authCallback(e){return i(this,void 0,void 0,(function*(){const t=new URLSearchParams(window.location.search),r=t.get("error"),n=t.get("error_description"),i=t.get("code");if(null!==r)throw new y(r,n);if(null===i)throw new y("missing_code");if(this.pendingAuthCallbacks.has(i))return;const o=this.storage.getCodeVerifier();this.storage.clearCodeVerifier(),this.pendingAuthCallbacks.add(i);const[a,s]=yield this.client.authCallback(i,e,o||void 0);this.pendingAuthCallbacks.delete(i),this.storage.setTokenInfo(a),this.storage.setUserinfo(s)}))}refreshUserinfo(){return i(this,void 0,void 0,(function*(){const e=this.getTokenInfo();if(null===e)throw new w;const t=yield this.client.userinfo(e.access_token);return this.storage.setUserinfo(t),t}))}logout(e){return i(this,void 0,void 0,(function*(){this.storage.clearUserinfo(),this.storage.clearTokeninfo();const t=yield this.client.getLogoutURL({redirectURI:e});window.location.href=t}))}}}),E=crypto;const m=e=>e instanceof CryptoKey,A=async(e,t)=>{const r=`SHA-${e.slice(-3)}`;return new Uint8Array(await E.subtle.digest(r,t))},S=new TextEncoder,v=new TextDecoder,b=2**32;function C(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;return e.forEach((e=>{r.set(e,n),n+=e.length})),r}function R(e,t,r){if(t<0||t>=b)throw new RangeError(`value must be >= 0 and <= ${b-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function _(e){const t=new Uint8Array(4);return R(t,e),t}function k(e){return C(_(e.length),e)}const O=e=>{let t=e;t instanceof Uint8Array&&(t=v.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class T extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}}class K extends T{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}}class P extends T{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}}class I extends T{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class H extends T{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class W extends T{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class J extends T{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class U extends T{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class D extends T{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class x extends T{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class j extends T{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class M extends T{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}class $ extends T{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var F=E.getRandomValues.bind(E);const L=(e,t)=>{if(t.length<<3!==function(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new H(`Unsupported JWE Algorithm: ${e}`)}}(e))throw new J("Invalid Initialization Vector length")},N=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new J(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)};function G(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function B(e,t){return e.name===t}function V(e){return parseInt(e.name.slice(4),10)}function z(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function Y(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!B(e.algorithm,"HMAC"))throw G("HMAC");const r=parseInt(t.slice(2),10);if(V(e.algorithm.hash)!==r)throw G(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!B(e.algorithm,"RSASSA-PKCS1-v1_5"))throw G("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(V(e.algorithm.hash)!==r)throw G(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!B(e.algorithm,"RSA-PSS"))throw G("RSA-PSS");const r=parseInt(t.slice(2),10);if(V(e.algorithm.hash)!==r)throw G(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw G("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!B(e.algorithm,"ECDSA"))throw G("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw G(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}z(e,r)}function q(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!B(e.algorithm,"AES-GCM"))throw G("AES-GCM");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw G(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!B(e.algorithm,"AES-KW"))throw G("AES-KW");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw G(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw G("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!B(e.algorithm,"PBKDF2"))throw G("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!B(e.algorithm,"RSA-OAEP"))throw G("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;if(V(e.algorithm.hash)!==r)throw G(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}z(e,r)}function X(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var Z=(e,...t)=>X("Key must be ",e,...t);function Q(e,t,...r){return X(`Key for the ${e} algorithm must be `,t,...r)}var ee=e=>m(e);const te=["CryptoKey"];async function re(e,t,r,n,i,o){if(!(t instanceof Uint8Array))throw new TypeError(Z(t,"Uint8Array"));const a=parseInt(e.slice(1,4),10),s=await E.subtle.importKey("raw",t.subarray(a>>3),"AES-CBC",!1,["decrypt"]),c=await E.subtle.importKey("raw",t.subarray(0,a>>3),{hash:"SHA-"+(a<<1),name:"HMAC"},!1,["sign"]),d=C(o,n,r,function(e){const t=Math.floor(e/b),r=e%b,n=new Uint8Array(8);return R(n,t,0),R(n,r,4),n}(o.length<<3)),h=new Uint8Array((await E.subtle.sign("HMAC",c,d)).slice(0,a>>3));let l,u;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,i=-1;for(;++i<r;)n|=e[i]^t[i];return 0===n})(i,h)}catch(e){}if(!l)throw new W;try{u=new Uint8Array(await E.subtle.decrypt({iv:n,name:"AES-CBC"},s,r))}catch(e){}if(!u)throw new W;return u}const ne=async(e,t,r,n,i,o)=>{if(!(m(t)||t instanceof Uint8Array))throw new TypeError(Z(t,...te,"Uint8Array"));switch(L(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&N(t,parseInt(e.slice(-3),10)),re(e,t,r,n,i,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&N(t,parseInt(e.slice(1,4),10)),async function(e,t,r,n,i,o){let a;t instanceof Uint8Array?a=await E.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(q(t,e,"decrypt"),a=t);try{return new Uint8Array(await E.subtle.decrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},a,C(r,i)))}catch(e){throw new W}}(e,t,r,n,i,o);default:throw new H("Unsupported JWE Content Encryption Algorithm")}},ie=async()=>{throw new H('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},oe=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function ae(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const se=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];const ce=async(e,t,r)=>{const n=await function(e,t,r){if(m(e))return q(e,t,r),e;if(e instanceof Uint8Array)return E.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(Z(e,...te,"Uint8Array"))}(t,e,"unwrapKey");!function(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}(n,e);const i=await E.subtle.unwrapKey("raw",r,n,"AES-KW",...se);return new Uint8Array(await E.subtle.exportKey("raw",i))};async function de(e,t,r,n,i=new Uint8Array(0),o=new Uint8Array(0)){if(!m(e))throw new TypeError(Z(e,...te));if(q(e,"ECDH"),!m(t))throw new TypeError(Z(t,...te));q(t,"ECDH","deriveBits");const a=C(k(S.encode(r)),k(i),k(o),_(n));let s;s="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,r){const n=Math.ceil((t>>3)/32),i=new Uint8Array(32*n);for(let t=0;t<n;t++){const n=new Uint8Array(4+e.length+r.length);n.set(_(t+1)),n.set(e,4),n.set(r,4+e.length),i.set(await A("sha256",n),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await E.subtle.deriveBits({name:e.algorithm.name,public:e},t,s)),n,a)}async function he(e,t,r,n){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new J("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return C(S.encode(e),new Uint8Array([0]),t)}(t,e),o=parseInt(t.slice(13,16),10),a={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:i},s={length:o,name:"AES-KW"},c=await function(e,t){if(e instanceof Uint8Array)return E.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(m(e))return q(e,t,"deriveBits","deriveKey"),e;throw new TypeError(Z(e,...te,"Uint8Array"))}(n,t);if(c.usages.includes("deriveBits"))return new Uint8Array(await E.subtle.deriveBits(a,c,o));if(c.usages.includes("deriveKey"))return E.subtle.deriveKey(a,c,s,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const le=async(e,t,r,n,i)=>{const o=await he(i,e,n,t);return ce(e.slice(-6),o,r)};function ue(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new H(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var fe=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const pe=async(e,t,r)=>{if(!m(t))throw new TypeError(Z(t,...te));if(q(t,e,"decrypt","unwrapKey"),fe(e,t),t.usages.includes("decrypt"))return new Uint8Array(await E.subtle.decrypt(ue(e),t,r));if(t.usages.includes("unwrapKey")){const n=await E.subtle.unwrapKey("raw",r,t,ue(e),...se);return new Uint8Array(await E.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function ye(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new H(`Unsupported JWE Algorithm: ${e}`)}}var we=e=>F(new Uint8Array(ye(e)>>3));const ge=async e=>{var t,r;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:n,keyUsages:i}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new H(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new H('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new H('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new H('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new H('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new H('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),o=[n,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:i];if("PBKDF2"===n.name)return E.subtle.importKey("raw",O(e.k),...o);const a={...e};return delete a.alg,delete a.use,E.subtle.importKey("jwk",a,...o)};async function Ee(e,t,r){var n;if(!ae(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?ge({...e,alg:t,ext:null!==(n=e.ext)&&void 0!==n&&n}):O(e.k);case"RSA":if(void 0!==e.oth)throw new H('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ge({...e,alg:t});default:throw new H('Unsupported "kty" (Key Type) Parameter value')}}const me=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!ee(t))throw new TypeError(Q(e,t,...te,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${te.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!ee(t))throw new TypeError(Q(e,t,...te));if("secret"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)};async function Ae(e,t,r,n,i){switch(me(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new J("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new J("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ae(n.epk))throw new J('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!function(e){if(!m(e))throw new TypeError(Z(e,...te));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}(t))throw new H("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await Ee(n.epk,e);let o,a;if(void 0!==n.apu){if("string"!=typeof n.apu)throw new J('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{o=O(n.apu)}catch(e){throw new J("Failed to base64url decode the apu")}}if(void 0!==n.apv){if("string"!=typeof n.apv)throw new J('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{a=O(n.apv)}catch(e){throw new J("Failed to base64url decode the apv")}}const s=await de(i,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?ye(n.enc):parseInt(e.slice(-5,-2),10),o,a);if("ECDH-ES"===e)return s;if(void 0===r)throw new J("JWE Encrypted Key missing");return ce(e.slice(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new J("JWE Encrypted Key missing");return pe(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===r)throw new J("JWE Encrypted Key missing");if("number"!=typeof n.p2c)throw new J('JOSE Header "p2c" (PBES2 Count) missing or invalid');const o=(null==i?void 0:i.maxPBES2Count)||1e4;if(n.p2c>o)throw new J('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof n.p2s)throw new J('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let a;try{a=O(n.p2s)}catch(e){throw new J("Failed to base64url decode the p2s")}return le(e,t,r,n.p2c,a)}case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new J("JWE Encrypted Key missing");return ce(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===r)throw new J("JWE Encrypted Key missing");if("string"!=typeof n.iv)throw new J('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof n.tag)throw new J('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,o;try{i=O(n.iv)}catch(e){throw new J("Failed to base64url decode the iv")}try{o=O(n.tag)}catch(e){throw new J("Failed to base64url decode the tag")}return async function(e,t,r,n,i){const o=e.slice(0,7);return ne(o,t,r,n,i,new Uint8Array(0))}(e,t,r,i,o)}default:throw new H('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function Se(e,t,r,n,i){if(void 0!==i.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!o.has(t))throw new H(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}const ve=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function be(e,t,r){if(e instanceof Uint8Array&&(e=v.decode(e)),"string"!=typeof e)throw new J("Compact JWE must be a string or Uint8Array");const{0:n,1:i,2:o,3:a,4:s,length:c}=e.split(".");if(5!==c)throw new J("Invalid Compact JWE");const d=await async function(e,t,r){var n;if(!ae(e))throw new J("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new J("JOSE Header missing");if("string"!=typeof e.iv)throw new J("JWE Initialization Vector missing or incorrect type");if("string"!=typeof e.ciphertext)throw new J("JWE Ciphertext missing or incorrect type");if("string"!=typeof e.tag)throw new J("JWE Authentication Tag missing or incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new J("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new J("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new J("JWE AAD incorrect type");if(void 0!==e.header&&!ae(e.header))throw new J("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ae(e.unprotected))throw new J("JWE Per-Recipient Unprotected Header incorrect type");let i;if(e.protected)try{const t=O(e.protected);i=JSON.parse(v.decode(t))}catch(e){throw new J("JWE Protected Header is invalid")}if(!oe(i,e.header,e.unprotected))throw new J("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const o={...i,...e.header,...e.unprotected};if(Se(J,new Map,null==r?void 0:r.crit,i,o),void 0!==o.zip){if(!i||!i.zip)throw new J('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==o.zip)throw new H('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:a,enc:s}=o;if("string"!=typeof a||!a)throw new J("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof s||!s)throw new J("missing JWE Encryption Algorithm (enc) in JWE Header");const c=r&&ve("keyManagementAlgorithms",r.keyManagementAlgorithms),d=r&&ve("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(c&&!c.has(a))throw new I('"alg" (Algorithm) Header Parameter not allowed');if(d&&!d.has(s))throw new I('"enc" (Encryption Algorithm) Header Parameter not allowed');let h;if(void 0!==e.encrypted_key)try{h=O(e.encrypted_key)}catch(e){throw new J("Failed to base64url decode the encrypted_key")}let l,u,f,p=!1;"function"==typeof t&&(t=await t(i,e),p=!0);try{l=await Ae(a,t,h,o,r)}catch(e){if(e instanceof TypeError||e instanceof J||e instanceof H)throw e;l=we(s)}try{u=O(e.iv)}catch(e){throw new J("Failed to base64url decode the iv")}try{f=O(e.tag)}catch(e){throw new J("Failed to base64url decode the tag")}const y=S.encode(null!==(n=e.protected)&&void 0!==n?n:"");let w,g;w=void 0!==e.aad?C(y,S.encode("."),S.encode(e.aad)):y;try{g=O(e.ciphertext)}catch(e){throw new J("Failed to base64url decode the ciphertext")}let E=await ne(s,l,g,u,f,w);"DEF"===o.zip&&(E=await((null==r?void 0:r.inflateRaw)||ie)(E));const m={plaintext:E};if(void 0!==e.protected&&(m.protectedHeader=i),void 0!==e.aad)try{m.additionalAuthenticatedData=O(e.aad)}catch(e){throw new J("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(m.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(m.unprotectedHeader=e.header),p?{...m,key:t}:m}({ciphertext:a,iv:o||void 0,protected:n||void 0,tag:s||void 0,encrypted_key:i||void 0},t,r),h={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...h,key:d.key}:h}const Ce=async(e,t,r,n)=>{const i=await function(e,t,r){if(m(t))return Y(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(Z(t,...te));return E.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(Z(t,...te,"Uint8Array"))}(e,t,"verify");fe(e,i);const o=function(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new H(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e,i.algorithm);try{return await E.subtle.verify(o,i,r,n)}catch(e){return!1}};async function Re(e,t,r){if(e instanceof Uint8Array&&(e=v.decode(e)),"string"!=typeof e)throw new U("Compact JWS must be a string or Uint8Array");const{0:n,1:i,2:o,length:a}=e.split(".");if(3!==a)throw new U("Invalid Compact JWS");const s=await async function(e,t,r){var n;if(!ae(e))throw new U("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new U('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new U("JWS Protected Header incorrect type");if(void 0===e.payload)throw new U("JWS Payload missing");if("string"!=typeof e.signature)throw new U("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ae(e.header))throw new U("JWS Unprotected Header incorrect type");let i={};if(e.protected)try{const t=O(e.protected);i=JSON.parse(v.decode(t))}catch(e){throw new U("JWS Protected Header is invalid")}if(!oe(i,e.header))throw new U("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o={...i,...e.header};let a=!0;if(Se(U,new Map([["b64",!0]]),null==r?void 0:r.crit,i,o).has("b64")&&(a=i.b64,"boolean"!=typeof a))throw new U('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=o;if("string"!=typeof s||!s)throw new U('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=r&&ve("algorithms",r.algorithms);if(c&&!c.has(s))throw new I('"alg" (Algorithm) Header Parameter not allowed');if(a){if("string"!=typeof e.payload)throw new U("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new U("JWS Payload must be a string or an Uint8Array instance");let d=!1;"function"==typeof t&&(t=await t(i,e),d=!0),me(s,t,"verify");const h=C(S.encode(null!==(n=e.protected)&&void 0!==n?n:""),S.encode("."),"string"==typeof e.payload?S.encode(e.payload):e.payload);let l,u;try{l=O(e.signature)}catch(e){throw new U("Failed to base64url decode the signature")}if(!await Ce(s,t,l,h))throw new $;if(a)try{u=O(e.payload)}catch(e){throw new U("Failed to base64url decode the payload")}else u="string"==typeof e.payload?S.encode(e.payload):e.payload;const f={payload:u};return void 0!==e.protected&&(f.protectedHeader=i),void 0!==e.header&&(f.unprotectedHeader=e.header),d?{...f,key:t}:f}({payload:i,protected:n,signature:o},t,r),c={payload:s.payload,protectedHeader:s.protectedHeader};return"function"==typeof t?{...c,key:s.key}:c}const _e=86400,ke=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;var Oe=e=>{const t=ke.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(r*_e);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}};const Te=e=>e.toLowerCase().replace(/^application\//,"");var Ke=(e,t,r={})=>{const{typ:n}=r;if(n&&("string"!=typeof e.typ||Te(e.typ)!==Te(n)))throw new K('unexpected "typ" JWT header value',"typ","check_failed");let i;try{i=JSON.parse(v.decode(t))}catch(e){}if(!ae(i))throw new D("JWT Claims Set must be a top-level JSON object");const{requiredClaims:o=[],issuer:a,subject:s,audience:c,maxTokenAge:d}=r;void 0!==d&&o.push("iat"),void 0!==c&&o.push("aud"),void 0!==s&&o.push("sub"),void 0!==a&&o.push("iss");for(const e of new Set(o.reverse()))if(!(e in i))throw new K(`missing required "${e}" claim`,e,"missing");if(a&&!(Array.isArray(a)?a:[a]).includes(i.iss))throw new K('unexpected "iss" claim value',"iss","check_failed");if(s&&i.sub!==s)throw new K('unexpected "sub" claim value',"sub","check_failed");if(c&&(h=i.aud,l="string"==typeof c?[c]:c,!("string"==typeof h?l.includes(h):Array.isArray(h)&&l.some(Set.prototype.has.bind(new Set(h))))))throw new K('unexpected "aud" claim value',"aud","check_failed");var h,l;let u;switch(typeof r.clockTolerance){case"string":u=Oe(r.clockTolerance);break;case"number":u=r.clockTolerance;break;case"undefined":u=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:f}=r,p=(y=f||new Date,Math.floor(y.getTime()/1e3));var y;if((void 0!==i.iat||d)&&"number"!=typeof i.iat)throw new K('"iat" claim must be a number',"iat","invalid");if(void 0!==i.nbf){if("number"!=typeof i.nbf)throw new K('"nbf" claim must be a number',"nbf","invalid");if(i.nbf>p+u)throw new K('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==i.exp){if("number"!=typeof i.exp)throw new K('"exp" claim must be a number',"exp","invalid");if(i.exp<=p-u)throw new P('"exp" claim timestamp check failed',"exp","check_failed")}if(d){const e=p-i.iat;if(e-u>("number"==typeof d?d:Oe(d)))throw new P('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-u)throw new K('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return i};async function Pe(e,t,r){var n;const i=await Re(e,t,r);if((null===(n=i.protectedHeader.crit)||void 0===n?void 0:n.includes("b64"))&&!1===i.protectedHeader.b64)throw new D("JWTs MUST NOT use unencoded payload");const o={payload:Ke(i.protectedHeader,i.payload,r),protectedHeader:i.protectedHeader};return"function"==typeof t?{...o,key:i.key}:o}function Ie(e){return ae(e)}class He{constructor(e){if(this._cached=new WeakMap,!function(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(Ie)}(e))throw new x("JSON Web Key Set malformed");var t;this._jwks=(t=e,"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t)))}async getKey(e,t){const{alg:r,kid:n}={...e,...null==t?void 0:t.header},i=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new H('Unsupported "alg" value for a JSON Web Key Set')}}(r),o=this._jwks.keys.filter((e=>{let t=i===e.kty;if(t&&"string"==typeof n&&(t=n===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv}return t})),{0:a,length:s}=o;if(0===s)throw new j;if(1!==s){const e=new M,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of o)try{yield await We(t,e,r)}catch(e){continue}},e}return We(this._cached,a,r)}}async function We(e,t,r){const n=e.get(t)||e.set(t,{}).get(t);if(void 0===n[r]){const e=await Ee({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new x("JSON Web Key Set members must be public keys");n[r]=e}return n[r]}function Je(e){const t=new He(e);return async function(e,r){return t.getKey(e,r)}}var Ue={};class De extends Error{}const xe=e=>{const t=[];return Object.keys(e).forEach((r=>{Object.prototype.hasOwnProperty.call(e,r)&&t.push(`${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`)})),t.join("&")};var je;e.FiefACR=void 0,(je=e.FiefACR||(e.FiefACR={})).LEVEL_ZERO="0",je.LEVEL_ONE="1";const Me=[e.FiefACR.LEVEL_ZERO,e.FiefACR.LEVEL_ONE];class $e extends Error{}class Fe extends $e{constructor(e,t){super(`[${e}] - ${t}`),this.status=e,this.detail=t}}class Le extends $e{}class Ne extends $e{}class Ge extends $e{}class Be extends $e{}class Ve extends $e{}class ze extends $e{}class Ye{constructor(e){this.baseURL=e.baseURL,this.clientId=e.clientId,this.clientSecret=e.clientSecret,void 0!==e.encryptionKey&&Ee(JSON.parse(e.encryptionKey),"RSA-OAEP-256").then((e=>{this.encryptionKey=e})),this.fetch=(()=>{if("undefined"!=typeof window&&window.fetch)return window.fetch.bind(window);if("undefined"!=typeof self&&self.fetch)return self.fetch.bind(self);if("undefined"!=typeof globalThis&&globalThis.fetch)return globalThis.fetch.bind(globalThis);if("function"==typeof require)return Ue;throw new De("Cannot find a fetch implementation for your environment")})(),this.crypto=l()}getAuthURL(e){return i(this,void 0,void 0,(function*(){const t=yield this.getOpenIDConfiguration(),{redirectURI:r,state:n,scope:i,codeChallenge:o,codeChallengeMethod:a,lang:s,extrasParams:c}=e,d=new URLSearchParams(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({response_type:"code",client_id:this.clientId,redirect_uri:r},n?{state:n}:{}),o?{code_challenge:o}:{}),a?{code_challenge_method:a}:{}),n?{state:n}:{}),i?{scope:i.join(" ")}:{}),s?{lang:s}:{}),c?Object.assign({},c):{}));return`${t.authorization_endpoint}?${d.toString()}`}))}authCallback(e,t,r){return i(this,void 0,void 0,(function*(){const n=yield this.getOpenIDConfiguration(),i=xe(Object.assign(Object.assign({grant_type:"authorization_code",client_id:this.clientId,code:e,redirect_uri:t},this.clientSecret?{client_secret:this.clientSecret}:{}),r?{code_verifier:r}:{})),o=yield this.fetch(n.token_endpoint,{method:"POST",body:i,headers:{"Content-Type":"application/x-www-form-urlencoded"}});yield Ye.handleRequestError(o);const a=yield o.json();return[a,yield this.decodeIDToken({idToken:a.id_token,jwks:yield this.getJWKS(),code:e,accessToken:a.access_token})]}))}authRefreshToken(e,t){return i(this,void 0,void 0,(function*(){const r=yield this.getOpenIDConfiguration(),n=xe(Object.assign({grant_type:"refresh_token",client_id:this.clientId,refresh_token:e},t?{scope:t.join(" ")}:{})),i=yield this.fetch(r.token_endpoint,{method:"POST",body:n,headers:{"Content-Type":"application/x-www-form-urlencoded"}});yield Ye.handleRequestError(i);const o=yield i.json();return[o,yield this.decodeIDToken({idToken:o.id_token,jwks:yield this.getJWKS(),accessToken:o.access_token})]}))}validateAccessToken(t,r,n,o){return i(this,void 0,void 0,(function*(){const i=Je(yield this.getJWKS());try{const{payload:c}=yield Pe(t,i),d=c.scope;if(void 0===d)throw new Le;const h=d.split(" ");r&&r.forEach((e=>{if(!h.some((t=>t===e)))throw new Ge}));const l=c.acr;if(void 0===l||!Object.values(e.FiefACR).includes(l))throw new Le;if(n&&(a=l,s=n,Me.findIndex((e=>e===a))-Me.findIndex((e=>e===s))<0))throw new Be;const u=c.permissions;if(void 0===u)throw new Le;return o&&o.forEach((e=>{if(!u.some((t=>t===e)))throw new Ve})),{id:c.sub,scope:h,acr:l,permissions:u,access_token:t}}catch(e){if(e instanceof P)throw new Ne;if(e instanceof T)throw new Le;throw e}var a,s}))}userinfo(e){return i(this,void 0,void 0,(function*(){const t=yield this.getOpenIDConfiguration(),r=yield this.fetch(t.userinfo_endpoint,{method:"GET",headers:{Authorization:`Bearer ${e}`}});yield Ye.handleRequestError(r);return yield r.json()}))}updateProfile(e,t){return i(this,void 0,void 0,(function*(){const r=`${this.baseURL}/api/profile`,n=yield this.fetch(r,{method:"PATCH",body:JSON.stringify(t),headers:{"Content-Type":"application/json",Authorization:`Bearer ${e}`}});yield Ye.handleRequestError(n);return yield n.json()}))}changePassword(e,t){return i(this,void 0,void 0,(function*(){const r=`${this.baseURL}/api/password`,n=yield this.fetch(r,{method:"PATCH",body:JSON.stringify({password:t}),headers:{"Content-Type":"application/json",Authorization:`Bearer ${e}`}});yield Ye.handleRequestError(n);return yield n.json()}))}emailChange(e,t){return i(this,void 0,void 0,(function*(){const r=`${this.baseURL}/api/email/change`,n=yield this.fetch(r,{method:"PATCH",body:JSON.stringify({email:t}),headers:{"Content-Type":"application/json",Authorization:`Bearer ${e}`}});yield Ye.handleRequestError(n);return yield n.json()}))}emailVerify(e,t){return i(this,void 0,void 0,(function*(){const r=`${this.baseURL}/api/email/verify`,n=yield this.fetch(r,{method:"POST",body:JSON.stringify({code:t}),headers:{"Content-Type":"application/json",Authorization:`Bearer ${e}`}});yield Ye.handleRequestError(n);return yield n.json()}))}getLogoutURL(e){return i(this,void 0,void 0,(function*(){const t=new URLSearchParams({redirect_uri:e.redirectURI});return`${this.baseURL}/logout?${t.toString()}`}))}getOpenIDConfiguration(){return i(this,void 0,void 0,(function*(){if(void 0!==this.openIDConfiguration)return this.openIDConfiguration;const e=yield this.fetch(`${this.baseURL}/.well-known/openid-configuration`,{method:"GET"});yield Ye.handleRequestError(e);const t=e.json();return this.openIDConfiguration=t,t}))}getJWKS(){return i(this,void 0,void 0,(function*(){if(void 0!==this.jwks)return this.jwks;const e=yield this.getOpenIDConfiguration(),t=yield this.fetch(e.jwks_uri,{method:"GET"});yield Ye.handleRequestError(t);const r=yield t.json();return this.jwks=r,r}))}decodeIDToken(e){return i(this,void 0,void 0,(function*(){const{idToken:t,jwks:r,code:n,accessToken:i}=e,o=Je(r);try{let e=t;if(void 0!==this.encryptionKey){const{plaintext:r}=yield be(t,this.encryptionKey);e=r}const{payload:r}=yield Pe(e,o);if(!(void 0===r.c_hash||n&&(yield this.crypto.isValidHash(n,r.c_hash))))throw new ze;if(!(void 0===r.at_hash||i&&(yield this.crypto.isValidHash(i,r.at_hash))))throw new ze;return r}catch(e){if(e instanceof T)throw new ze;throw e}}))}static handleRequestError(e){return i(this,void 0,void 0,(function*(){if(e.status<200||e.status>299){const t=yield e.text();throw new Fe(e.status,t)}}))}}e.Fief=Ye,e.FiefAccessTokenACRTooLow=Be,e.FiefAccessTokenExpired=Ne,e.FiefAccessTokenInvalid=Le,e.FiefAccessTokenMissingPermission=Ve,e.FiefAccessTokenMissingScope=Ge,e.FiefError=$e,e.FiefIdTokenInvalid=ze,e.FiefRequestError=Fe,e.browser=g,e.crypto=u,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
